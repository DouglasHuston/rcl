<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../elements/cgroup-edit-form/cgroup-edit-form.html">
<link rel="import" href="../../elements/cgroup-filter/cgroup-filter.html">
<link rel="import" href="../../elements/model-object/model-object.html">
<link rel="import" href="../../bower_components/google-apis/google-maps-api.html">

<dom-module id="import-a-directory" hoodie="{{hoodie}}" >
  <style>
    :host {
      display: block;
      padding: 1em;
    }
    paper-material {
      padding: 1em;
    }
  </style>
  <template>
    <model-object id="model_object"></model-object>
    <paper-material elevation="1">
      <h1>Import a directory</h1>
      <div>Select an import.io file</div>
      <paper-input type="file" on-change="_handle_file_selected"></paper-input>
      <div hidden="{{hide_cgroup_filter}}">
        <p>Which denomination does this directory represent?</p>
        <cgroup-filter id="cgroup_filter"
          select_one_mode></cgroup-filter>
        <cgroup-edit-form id="cgroup_edit_form" hidden="{{hide_cgroup_edit_form}}" cgroup="{{cgroup}}"></cgroup-edit-form>
      </div>
      <geocode-stats hidden="{{hide_geocode_stats}}"></geocode-stats>
    </paper-material>
    <google-maps-api api-key="AIzaSyCcl9RJaWMuEF50weas-we3D7kns-iWEXQ" version="3.exp" id="maps_api"></google-maps-api>
  </template>
</dom-module>
<script>
(function() {
  
  'use strict';

  Polymer({
    is: 'import-a-directory',

    properties: {
      hoodie: {
        type: Object,
        notify: true,
        reflectToAttribute: true
      },
      hide_geocode_stats: {
        type: Boolean,
        value: true,
        notify: true
      },
      hide_cgroup_edit_form: {
        type: Boolean,
        value: true,
        notify: true
      },
      hide_cgroup_filter: {
        type: Boolean,
        value: true,
        notify: true
      },
      cgroup: {
        type: Object,
        value: {},
        notify: true
      }
    },
    ready:function(){
      // TODO: Delete API key above, and ask user to get and enter their own API key for their upload
    },
    attached:function(){
      this.async(function(){
        this.hoodie = document.querySelector('hoodie-accountbar').hoodie;
      });
    },
    /* This function:
     * - gets directory and congregation data from a user-selected import.io file
     * - writes directory and associated cgroup data to the database
     * - geocodes congregations if necessary
     * - writes congregations into the database
     */
    _handle_file_selected:function(event){
      // from old URLView.js:importio_drop_target_drop
      // Get file contents here
      var file = event.target.files[0];
      var reader = new FileReader();
      var thiz = this;
      reader.addEventListener('load', function loadEnd(){
        reader.removeEventListener(event.type, loadEnd);
        var json = reader.result;
        var congs_obj = JSON.parse(json);
        // Determine if this import.io data source is already in a directory in the database.
        // Note that
        //  - directory objects represent remote church directory websites, and
        //  - cgroup objects represent one denomination or group like the OPC, NAPARC, etc.
        //  So this directory's congregations fall in one or more cgroups, so we need
        //    to load a <cgroup-filter> here to allow the user to select the correct cgroup.
        //  Use the importio_guid to determine this
        var importio_guid = congs_obj.data[0]._source[0];
        // Get this directory if it exists in the db
//         thiz.hoodie.store.removeAll('directory');
//         return;
        thiz.hoodie.store.findAll(function(object){
          if (object.type === 'directory' && object.importio_guid === importio_guid){
            return true;
          }
        })
        .done(function(directories){
          // TODO: Refactor from here down into reusable methods, especially because the cong 
          //  translation & geocoding block is big, and needed in both conditional blocks below.
          if (directories.length !== 0){
            // Then display this directory's cgroups
            var directory = directories[0];
            // Find the cgroups to which this directory's congregations belong, and display them in the
            //  <cgroup-filter>
            thiz.hoodie.store.findAll('cgroup')
            .done(function(available_cgroups){
              thiz.$.cgroup_filter.available_cgroups = available_cgroups;
              // Get related cgroup
              thiz.hoodie.store.find('cgroup', directory.cgroup_id)
              .done(function(cgroup){
                // Display related cgroup in <cgroup-filter>
                thiz.$.cgroup_filter.selected_cgroups = [cgroup];
                thiz.hide_cgroup_filter = false;
                // TODO: Set up listener (elsewhere in the code) to handle updating the cgroup_directory
                //  docs with their new new cgroups.
              })
              .fail(function(error){
                console.log(error);
              });
            })
            .fail(function(error){
              console.log(error);
            });
          }else{
            // Else create this directory
            
            // Get domain name
            var a = document.createElement('a');
            a.href = congs_obj.data[0]._pageUrl;
            var domain_name = a.hostname;
            
            // Create directory
            thiz.hoodie.store.add('directory', {
              importio_guid: importio_guid,
              url: domain_name, // url of directory's main page, approximated to domain name
              directory_type:'importio'
            })

            // Associate one cgroup with this directory
            .done(function(directory){
              
              // Display <cgroup-filter> to permit user to select or create the related cgroup
              thiz.hoodie.store.findAll('cgroup')
              .done(function(available_cgroups){
                thiz.$.cgroup_filter.available_cgroups = available_cgroups;
                thiz.hide_cgroup_filter = false;
                thiz.$.cgroup_filter.addEventListener('submit', function handle_cgroup_edit_form_submit(){
                  thiz.$.cgroup_filter.removeEventListener(event.type, handle_cgroup_edit_form_submit);
                  thiz.$.cgroup_filter.$.cgroup_edit_dialog.close();
                  thiz.hide_cgroup_filter = true;
                  thiz.hoodie.store.add('cgroup', thiz.$.cgroup_filter.$.cgroup_edit_form.cgroup)
                  .done(function(cgroup){
                    // Associate this new cgroup with the directory
                    thiz.hoodie.store.update('directory', directory.id, {cgroup_id: cgroup.id})
                    .done(function(directory){
                      thiz.geocode_and_save_congs(congs_obj, directory, cgroup);
                    })
                    .fail(function(error){
                      console.log(error);
                    });
                  })
                  .fail(function(error){
                    console.log(error);
                  });
                });
              });

//               // Set up event listener on cgroup_edit_form
//               thiz.$.cgroup_edit_form.addEventListener('submit', function handle_cgroup_edit_form_submit(event){
//                 thiz.$.cgroup_edit_form.removeEventListener(event.type, handle_cgroup_edit_form_submit);
//                 // Write the entered cgroup data to the db, and associate this cgroup with the directory
//                 // If directory.cgroup_id is undefined, we have to search for this cgroup in case it already
//                 //  exists.  But this would be easier to do before asking the user to fill out the form.  So
//                 //  we should use the <cgroup-filter> element here.
//                 // Else we should create a new cgroup
//                 thiz.hoodie.store.updateOrAdd('cgroup', directory.cgroup_id, thiz.$.cgroup_edit_form.cgroup)
//                 .done(function(cgroup){
//                   thiz.hide_cgroup_edit_form = true;
//                   debugger;
//                   thiz.hoodie.store.update('directory', directory.id, {cgroup_id: cgroup.id})
//                   .done(function(directory){})
//                   .fail(function(error){
//                     debugger;
//                     console.log(error);
//                   });
//                 })
//                 .fail(function(error){
//                   console.log(error);
//                 });
//               });
//               // Show form to edit cgroup information
//               thiz.hide_cgroup_edit_form = false;
              
              // TODO: Does the above work when directory.cgroup_id is null? No.
              //  Or does it create multiple copies of the new cgroup? Yes.
              //  So how can we fix this?

              // TODO: Handle adding or removing related cgroups. I think we should permit selecting only
              //  one cgroup here.  Will it be too hard to make cgroup-filter work this way?
              // Ask, "Which denomination or other group of churches does this directory represent?"
              // TODO: Add an element below cgroup-filter to permit adding a new cgroup 
              //  which doesn't exist.
              // TODO: When adding a new cgroup, ask the user to enter the name and abbreviation of the cgroup 
              // TODO: Write the congregations in this directory to the database
              // TODO: Should we associate the cgroup with these congs here?
            })
            .fail(function(error){
              console.log(error);
            });
          }
        });
        //  Consider writing all the data to the database first, then geocoding after that
        // TODO: Display form to let user describe this cgroup
        // Render stats view on geocoding progress
        //thiz.hide_geocode_stats = false;
        // TODO: Fire displaying next form fields here as needed
        // TODO: Get the directory's identity from the cong URLs
        // TODO: Display the form to edit the directory's name
        // TODO: Display a stats view to notify the user of the following stats:
        //  running total: X congs have been imported successfully
        //  event: All congs' data have been imported
        //  running total: X congs have been geocoded successfully
        //  event: All congs' data have been geocoded successfully
        //  event: X congs failed geocoding (offer link to view the details)
        
        // TODO: Prepare dirs, cgroups for determining whether this file's dir, cgroup is already in the database
      });
      reader.readAsText(file);
    },
    geocode_and_save_congs: function(congs_obj, directory, cgroup){
      var thiz = this;
      // TODO: Geocode and save the congregations
      // TODO: Check whether each congregation already exists. Maybe use updateOrAdd()?
      
      // TODO: Iterate through the congs to geocode each one.
      //  Can I do it as a queue of promises?
      //  Or maybe use updateAll() with a function, and filter for the correct type
      //    and identify each cong via an importio ID or other data.
      //  Hm...no, that won't work because updateAll() doesn't add new docs.
      // Note: The attribute which contains the list of cong data objects is called congs_obj.data
      var congs = congs_obj.data;
      congs.forEach(function(cong){
        // Note: Most attributes contain lists.
        // So if an attribute is a list is longer than 1 item, join the items together with <br />
        var new_cong = {};
        // Create a new object which has model.congregation as its prototype
        var cong_template = Object.create(thiz.$.model_object.model.congregation);
        // Import only the fields we want in our model
        cong_template.default_attributes.forEach(function handle_attribute(attribute){
            // Only join if it is of type = array
            new_cong[attribute] = Array.isArray(cong[attribute]) ? cong[attribute].join('<br />') : cong[attribute];
        });
        new_cong.contact_email = (new_cong.hasOwnProperty('contact_email') && typeof new_cong.contact_email !== 'undefined') ?
            new_cong.contact_email.replace('mailto:','') : '';
        // cong._pageUrl contains the cong's unique database id in the URL.  Note that we save this attribute since
        //  it is useful for identifying the cong and data source uniquely if we need to search for it or sync it.
        new_cong.page_url = cong._pageUrl;
        // Get cong's database id from OPC.org
        if (new_cong.page_url.indexOf('opc.org') !== -1){
            // Note that data[n].name is in ALLCAPS!!  So change to capitalize only the first 
            //  character of each word.
            // TODO: This doesn't work with names including words like 'of'. Maybe that's why they are ALLCAPS.
            new_cong.name = new_cong.name.toLowerCase().replace(/(?:^|\s)\S/g, function(a) { return a.toUpperCase(); });
        }
        // Save to database
        // Find out whether this cong exists in the database
        thiz.hoodie.store.findAll(function(cong_found){
          if (cong_found.type === 'congregation' && cong_found.page_url === new_cong.page_url){
            return true;
          }
        })
        .done(function(congs_found){
          if (congs_found.length > 0){
            // Cong already exists in the database, so update with new attributes
            var address_fields = [
              'meeting_address1',
              'meeting_address2',
              'meeting_city',
              'meeting_state',
              'meeting_zip'
            ];

            // Compare old address values with new address values.
            //  If the new_cong's values are different, then geocode this cong.
            var fields_changed = address_fields.filter(function(item){
              return new_cong[item] !== congs_found[0][item];
            });
            if (fields_changed.length > 0){
              thiz.geocode_cong(new_cong)
              .done(function(new_cong){
                // Update cong in database.
                return thiz.update_cong(congs_found[0].id, new_cong);
              })
              .fail(function(error){
                console.log(error);
              });
            }else{
              // Update cong in database.
              return thiz.update_cong(congs_found[0].id, new_cong);
            }
          }else{
            // Cong does not exist in database, so geocode, then create new doc
            thiz.geocode_cong(new_cong)
            .done(function(new_cong){
              // Add cong to database.
              thiz.hoodie.store.add('congregation', new_cong)
              .done(function(new_cong){})
              .fail(function(error){
                console.log(error);
              });
            })
            .fail(function(error){
              console.log(error);
            });
          }
        }).fail(function(error){
          console.log(error);
        });
        // TODO: Start here.  This should be integrated into the above, as should geocoding,
        //  though maybe that could be done in a Hoodie event listener.

        // TODO: Geocode congregation here.  But maybe not on the update event, unless
        //  we can determine if the address was updated.  How can we determine that here?
        //  Maybe that can only be determined in the code below right before we write an
        //  imported cong to the database. Maybe that is best because we don't want to
        //  trigger geocoding the same cong in more than one browser for just one address change.

        // Associate this cong with its cgroup
        cong_model.get('cgroups').add(thiz.cgroup);
        cong_model.set('denomination_abbr', thiz.cgroup.get('abbreviation'));
        cong_model.save();
        
      });
    },
    geocode_cong:function(cong){
      // Note that if the API takes a long time to load on a slow connection,
      //  it is possible that it would not yet be available.  That's unlikely by
      //  the time the user calls this method.  But if it happens, refer to the google-maps-api
      //  docs for how to initialize the following variable only after the API loads.
      var geocoder = this.$.maps_api.api.geocoder;
      // Get cong's address to geocode
      // Note this is limited to 2500 requests per day, then is "rate-limited on a per-second basis."
      //  See https://developers.google.com/maps/documentation/javascript/geocoding
      // Pick the meeting_address[1|2] which contains a number, else just use meeting_address1
      var address_line = ''
      if (cong.meeting_address1.search(/\d/) !== -1){
          address_line = cong.meeting_address1
      } else if (cong.meeting_address2.search(/\d/) !== -1){
          address_line = cong.meeting_address2
      }else{
          address_line = cong.meeting_address1
      }
      var address =   address_line + ', ' + 
                      (cong.meeting_city?cong.meeting_city: (cong.mailing_city?cong.mailing_city:'')) + ', ' + 
                      (cong.meeting_state?cong.meeting_state:  (cong.mailing_state?cong.mailing_state:'')) + ' ' + 
                      (cong.meeting_zip?cong.meeting_zip:  (cong.mailing_zip?cong.mailing_zip:''))
      // TODO: Start here.
      // TODO: Refactor this to return a promise.
      // TODO:  Consider how to refactor this to geocode only one cong at a time.
      //  Currently the code tries all at once, then when it realizes it's getting errors,
      //  it throttles back, but the effect of that throttling is probably to throttle back too
      //  much, so the whole geocoding batch runs much slower than it has to.  So the way to refactor
      //  this is to keep track of which cong is being handled, then only once one cong is geocoded,
      //  move on to the next cong.

      geocoder.geocode( { 'address': address }, function(results, status) {
          // console.log(results, status)
          // TODO: Handle when Google returns multiple possible address matches (results.length > 1, 
          //  or status == 'ZERO_RESULTS'
          if (status == google.maps.GeocoderStatus.OK) {
              var loc = results[0].geometry.location
              congs[index].loc = [loc.lat(), loc.lng()]
              // Delay bulkSave until after asynchronous geocoding is done for all congs
              congs[index].geocoding = 'done'
              thiz.geocode_end_time = new Date().getTime()
              bulksave(congs)
          }else{
              // === if we were sending the requests to fast, try this one again and increase the delay
              if (status == google.maps.GeocoderStatus.OVER_QUERY_LIMIT){
                  thiz.usecs += 100;
                  setTimeout(function(){
                      geocode(address, congs, index)
                  },thiz.usecs)
              }else{
                  var reason  =   "Code "+status;
                  var msg     = 'address="' + address + '" error=' +reason+ '(usecs='+thiz.usecs+'ms)';
                  if (typeof thiz.errors == 'undefined'){
                      thiz.errors = 1
                  }else{
                      thiz.errors++
                  }
                  console.error('Errors: ' + thiz.errors, msg)
              }
          }
      });
    },
    update_cong:function(id, cong){
      // Update cong in database
      return this.hoodie.store.update('congregation', id, cong)
      .done(function(cong){
        return cong;
      })
      .fail(function(error){
        console.log(error);
      });
    }

  });
})();
</script>
