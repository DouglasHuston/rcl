<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../elements/cgroup-edit-form/cgroup-edit-form.html">
<link rel="import" href="../../elements/cgroup-filter/cgroup-filter.html">
<link rel="import" href="../../elements/model-object/model-object.html">
<link rel="import" href="../../bower_components/google-apis/google-maps-api.html">

<dom-module id="import-a-directory" hoodie="{{hoodie}}" map="{{map}}">
  <style>
    :host {
      display: block;
      padding: 1em;
    }
    paper-material {
      padding: 1em;
    }
  </style>
  <template>
    <model-object id="model_object"></model-object>
    <paper-material elevation="1">
      <h1>Import a directory</h1>
      <div>Select an import.io file</div>
      <paper-input type="file" on-change="_handle_file_selected"></paper-input>
      <div hidden="{{hide_cgroup_filter}}">
        <p>Which denomination does this directory represent?</p>
        <cgroup-filter id="cgroup_filter"
          select_one_mode></cgroup-filter>
        <cgroup-edit-form id="cgroup_edit_form" hidden="{{hide_cgroup_edit_form}}" cgroup="{{cgroup}}"></cgroup-edit-form>
      </div>
      <geocode-stats hidden="{{hide_geocode_stats}}" id="geocode_stats"></geocode-stats>
    </paper-material>

  </template>
</dom-module>
<script>
(function() {
  
  'use strict';

  Polymer({
    is: 'import-a-directory',

    properties: {
      hoodie: {
        type: Object,
        notify: true,
        reflectToAttribute: true
      },
      hide_geocode_stats: {
        type: Boolean,
        value: true,
        notify: true
      },
      hide_cgroup_edit_form: {
        type: Boolean,
        value: true,
        notify: true
      },
      hide_cgroup_filter: {
        type: Boolean,
        value: true,
        notify: true
      },
      cgroup: {
        type: Object,
        value: {},
        notify: true
      },
      map: {
        type: Object,
        notify: true
      }
    },
    ready:function(){
      // TODO: Delete API key above, and ask user to get and enter their own API key for their upload
    },
    attached:function(){
      var thiz = this;
      this.async(function(){

        // Get reference to Hoodie
        this.hoodie = document.querySelector('hoodie-accountbar').hoodie;
        
        // Configure listener to congregation:change events
        this.hoodie.store.on('congregation:change', function(cong){
          // Handle congs with regeocode === true
          if (cong.regeocode === true){
            thiz._geocode_congs(0, [cong]);
          }
        });
        
        // Trigger regeocoding on page load, after a 5 second delay
        this.async(function(){
          this.hoodie.store.findAll(function(cong){
            if (cong.regeocode === true){
              return true;
            }
          })
          .done(function(congs){
            if (congs.length > 0){
              thiz._geocode_congs(0, congs);
            }
          }).fail(thiz.fail_handler);
        }, 5000);

      });
    },
    // Simple default promise fail handler to use throughout the code. It simply logs the error to the console.
    fail_handler:function(error){
      console.log(error);
    },
    /* This function:
     * - gets directory and congregation data from a user-selected import.io file
     * - writes directory and associated cgroup data to the database
     * - geocodes congregations if necessary
     * - writes congregations into the database
     */
    _handle_file_selected:function(event){
      // from old URLView.js:importio_drop_target_drop
      // Get file contents here
      var file = event.target.files[0];
      var reader = new FileReader();
      var thiz = this;
      reader.addEventListener('load', function loadEnd(){
        reader.removeEventListener(event.type, loadEnd);
        var json = reader.result;
        var congs_obj = JSON.parse(json);
        // Determine if this import.io data source is already in a directory in the database.
        // Note that
        //  - a directory object represents one remote church directory website, and
        //  - a cgroup object represents one denomination or group like the OPC, NAPARC, etc.
        //  - a directory represents one cgroup (not many)
        //  So, we need to load a <cgroup-filter> here to allow the user to select the directory's cgroup.
        //  Use the importio_guid to determine this
        var importio_guid = congs_obj.data[0]._source[0];
        // Get this directory if it exists in the db
        thiz.hoodie.store.removeAll('directory');
        return;
        thiz.hoodie.store.findAll(function(object){
          if (object.type === 'directory' && object.importio_guid === importio_guid){
            return true;
          }
        })
        .done(function(directories){
          // TODO: Refactor from here down into reusable methods, especially because the cong 
          //  translation & geocoding block is big, and needed in both conditional blocks below.
          if (directories.length > 1){
            console.error('There is more than one directory with this importio_guid!');
          }
          if (directories.length === 1){
            // Then display this directory's cgroup
            var directory = directories[0];
            // Find the cgroup which this directory represents, and display it in the <cgroup-filter>
            thiz.hoodie.store.findAll('cgroup')
            .done(function(available_cgroups){
              thiz.$.cgroup_filter.available_cgroups = available_cgroups;
              // Get related cgroup
              thiz.hoodie.store.find('cgroup', directory.cgroup_id)
              .done(function(cgroup){
                // Display related cgroup in <cgroup-filter>
                thiz.$.cgroup_filter.selected_cgroups = [cgroup];
                thiz.hide_cgroup_filter = false;
                // TODO: Set up listener (elsewhere in the code) to handle updating the cgroup_directory
                //  docs with their new new cgroups.
              }).fail(thiz.fail_handler);
            }).fail(thiz.fail_handler);
          }else{
            // Else create this directory
            
            // Get domain name
            var a = document.createElement('a');
            a.href = congs_obj.data[0]._pageUrl;
            var domain_name = a.hostname;
            
            // Create directory
            thiz.hoodie.store.add('directory', {
              importio_guid: importio_guid,
              url: domain_name, // url of directory's main page, approximated to domain name
              directory_type:'importio'
            })

            // Associate one cgroup with this directory
            .done(function(directory){
              
              // Display <cgroup-filter> to permit user to select or create the related cgroup
              thiz.hoodie.store.findAll('cgroup')
              .done(function(available_cgroups){
                thiz.$.cgroup_filter.available_cgroups = available_cgroups;
                thiz.hide_cgroup_filter = false;
                // TODO: Focus the paper-input to make it easy for a user to start typing
                thiz.$.cgroup_filter.addEventListener('submit', function handle_cgroup_edit_form_submit(){
                  thiz.$.cgroup_filter.removeEventListener(event.type, handle_cgroup_edit_form_submit);
                  thiz.$.cgroup_filter.$.cgroup_edit_dialog.close();
                  thiz.hide_cgroup_filter = true;
                  thiz.hoodie.store.add('cgroup', thiz.$.cgroup_filter.$.cgroup_edit_form.cgroup)
                  .done(function(cgroup){
                    // Associate this new cgroup with the directory
                    thiz.hoodie.store.update('directory', directory.id, {cgroup_id: cgroup.id})
                    .done(function(directory){
                      thiz._translate_and_save_congs(congs_obj, directory, cgroup);
                    }).fail(thiz.fail_handler);
                  }).fail(thiz.fail_handler);
                });
              });

              // TODO: Does the above work when directory.cgroup_id is null? No.
              //  Or does it create multiple copies of the new cgroup? Yes.
              //  So how can we fix this?

              // TODO: Write the congregations in this directory to the database
              // TODO: Should we associate the cgroup with these congs here?
            }).fail(thiz.fail_handler);
          }
        });
        //  Consider writing all the data to the database first, then geocoding after that
        // TODO: Display form to let user describe this cgroup
        // Render stats view on geocoding progress
        //thiz.hide_geocode_stats = false;
        // TODO: Fire displaying next form fields here as needed
        // TODO: Get the directory's identity from the cong URLs
        // TODO: Display the form to edit the directory's name
        // TODO: Display a stats view to notify the user of the following stats:
        //  running total: X congs have been imported successfully
        //  event: All congs' data have been imported
        //  running total: X congs have been geocoded successfully
        //  event: All congs' data have been geocoded successfully
        //  event: X congs failed geocoding (offer link to view the details)
        
        // TODO: Prepare dirs, cgroups for determining whether this file's dir, cgroup is already in the database
      });
      reader.readAsText(file);
    },
    /* Translate from importio cong format to our schema, then save the cong. Note this
     *  currently only handles an importio-formatted congs_obj.
     */
    _translate_and_save_congs: function(congs_obj, directory, cgroup){
      var thiz = this;
      // Note: The attribute which contains the list of cong data objects is called congs_obj.data
      var congs = congs_obj.data;

      congs.forEach(function(cong){
        // Note: Most attributes contain lists.
        // So if an attribute is a list is longer than 1 item, join the items together with <br />
        var new_cong = {};
        // Create a new object which has model.congregation as its prototype
        var cong_template = Object.create(thiz.$.model_object.model.congregation);
        // Import only the fields we want in our model
        Object.keys(cong_template.default_attributes).forEach(function handle_attribute(attribute){
            // Only join if it is of type = array
            new_cong[attribute] = Array.isArray(cong[attribute]) ? cong[attribute].join('<br />') : cong[attribute];
        });
        new_cong.contact_email = (new_cong.hasOwnProperty('contact_email') && typeof new_cong.contact_email !== 'undefined') ?
            new_cong.contact_email.replace('mailto:','') : '';
        // cong._pageUrl contains the cong's unique database id in the URL.  Note that we save this attribute since
        //  it is useful for identifying the cong and data source uniquely if we need to search for it or sync it.
        new_cong.page_url = cong._pageUrl;
        // Handle congs from OPC.org
        if (new_cong.page_url.indexOf('opc.org') !== -1){
            // Note that data[n].name is in ALLCAPS!!  So change to capitalize only the first 
            //  character of each word.
            // TODO: This doesn't work with names including words like 'of'. Maybe that's why they are ALLCAPS.
            new_cong.name = new_cong.name.toLowerCase().replace(/(?:^|\s)\S/g, function(a) { return a.toUpperCase(); });
        }
        // Record the source of this revision of this cong
        new_cong.source_id = directory.id;
        
        // Save to database
        // Find out whether this cong exists in the database
        thiz.hoodie.store.findAll(function(cong_found){
          if (cong_found.type === 'congregation' && cong_found.page_url === new_cong.page_url){
            return true;
          }
        })
        .done(function(congs_found){
          if (congs_found.length > 0){
            // Cong already exists in the database, so update with new attributes
            
            // Compare old address values with new address values.
            //  If the new_cong's values are different, then flag to geocode this cong.
            if (thiz._get_cong_address_to_geocode(new_cong) !== thiz._get_cong_address_to_geocode(congs_found[0])){
              // Set regeocode flag
              new_cong.regeocode = true;
            }
            
            // Update this cong's cgroups
            // First find all related cgroups
            thiz.hoodie.store.findAll(function(doc){
              if (doc.type === 'cgroup_congregation' &&
                  doc.congregation_id === congs_found[0].id && 
                  doc.cgroup_id === cgroup.id){
                return true;
              }
            })
            // Second, add this cgroup if it has not yet been added to the cong's cgroups
            .done(function(cgroup_congregations){
              if (cgroup_congregations.length === 0){
                thiz.hoodie.store.add('cgroup_congregation', {
                  cgroup_id: cgroup.id,
                  congregation_id: congs_found[0].id
                })
                .done(function(){}).fail(thiz.fail_handler);
              }
            }).fail(thiz.fail_handler);
            
            // Update in database
            thiz.update_cong(congs_found[0].id, new_cong);

          }else{
            
            // Cong does not exist in database, so flag to geocode, then create new doc
            new_cong.regeocode = true;
            thiz.hoodie.store.add('congregation', new_cong)
            .done(function(){

              // Create a join doc for this congregation's cgroup
              thiz.hoodie.store.add('cgroup_congregation', {
                cgroup_id: cgroup.id,
                congregation_id: congs_found[0].id
              })
              .done(function(){}).fail(thiz.fail_handler);

            }).fail(thiz.fail_handler);

          }
        }).fail(thiz.fail_handler);
      });
    },
    _get_cong_address_to_geocode:function(cong){
      // Get cong's address to geocode
      // Pick the meeting_address[1|2] which contains a number, else just use meeting_address1
      var address_line = '';
      if (cong.meeting_address1.search(/\d/) !== -1){
          address_line = cong.meeting_address1;
      } else if (cong.meeting_address2.search(/\d/) !== -1){
          address_line = cong.meeting_address2;
      }else{
          address_line = cong.meeting_address1;
      }
      var address =   address_line + ', ' + 
                      (cong.meeting_city?cong.meeting_city: (cong.mailing_city?cong.mailing_city:'')) + ', ' + 
                      (cong.meeting_state?cong.meeting_state:  (cong.mailing_state?cong.mailing_state:'')) + ' ' + 
                      (cong.meeting_zip?cong.meeting_zip:  (cong.mailing_zip?cong.mailing_zip:''));
      return address;      
    },
    // Recursive function which geocodes an array of congregations, and throttles back the rate 
    //  if the geocoder tells us we are geocoding too fast.
    _geocode_congs:function(index, congs_array, usecs){
      // Note that if the API takes a long time to load on a slow connection,
      //  it is possible that it would not yet be available.  That's unlikely by
      //  the time the user calls this method.  But if it happens, refer to the google-maps-api
      //  docs for how to initialize the following variable only after the API loads.
      var thiz = this;
      // Note the geocoder is limited to 2500 requests per day, then is "rate-limited on a per-second basis."
      //  See https://developers.google.com/maps/documentation/javascript/geocoding
      var geocoder = this.map.geocoder;
      if (typeof usecs === 'undefined'){
        usecs = 100;
      }

      // Report progress to user
      this.$.geocode_stats.usecs = usecs;
      this.$.geocode_stats.number_to_geocode = congs_array.length;
      
      var address = this._get_cong_address_to_geocode(congs_array[index]);
      geocoder.geocode( { 'address': address }, function(results, status) {
        // console.log(results, status)
        // TODO: Handle when Google returns multiple possible address matches (results.length > 1, 
        //  or status == 'ZERO_RESULTS'
        if (status === thiz.map.GeocoderStatus.OK) {
          var loc = results[0].geometry.location;
          congs_array[index].geocode = {lat:loc.lat(), lng: loc.lng()};
          // Save cong with updated geocode
          thiz.hoodie.store.update('congregation', congs_array[index].id, congs_array[index])
          .done(function(){
            
            // Report progress to user
            thiz.$.geocode_stats.number_geocoded = thiz.$.geocode_stats.number_geocoded++;

            // Call this function recursively to geocode the next cong
            index++;
            thiz._geocode_congs(index, congs_array, usecs);

          }).fail(thiz.fail_handler);
        }else{
          // If we were sending the requests to fast, try this cong again and increase the delay
          if (status === thiz.map.GeocoderStatus.OVER_QUERY_LIMIT){
            usecs += 100;
            setTimeout(function(){
              thiz._geocode_congs(index, congs_array, usecs);
            },usecs);
          }else{
            var reason  =   'Code ' + status;
            var msg     = 'address="' + address + '" error=' + reason + '(usecs=' + usecs + 'ms)';
            console.error('Error: ' + msg);
          }
        }
      });
    },
    update_cong:function(id, cong){
      // Update cong in database
      return this.hoodie.store.update('congregation', id, cong)
      .done(function(cong){
        return cong;
      }).fail(this.fail_handler);
    }

  });
})();
</script>
