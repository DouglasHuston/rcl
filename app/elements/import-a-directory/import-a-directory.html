<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../elements/cgroup-edit-form/cgroup-edit-form.html">
<link rel="import" href="../../elements/cgroup-filter/cgroup-filter.html">
<link rel="import" href="../../elements/model-object/model-object.html">
<link rel="import" href="../../bower_components/google-apis/google-maps-api.html">

<dom-module id="import-a-directory" hoodie="{{hoodie}}">
  <style>
    :host {
      display: block;
      padding: 1em;
    }
    paper-material {
      padding: 1em;
    }
    #continue_button {
      margin-top: 1em;
    }
  </style>
  <template>
    <model-object id="model_object"></model-object>
    <paper-material elevation="1">
      <h1>Import a directory</h1>
      <div>Select an import.io file</div>
      <paper-input type="file" on-change="_handle_file_selected"></paper-input>
      <div hidden="{{hide_cgroup_filter}}">
        <p>
          Which denomination does this directory represent?
        </p>
        <p>
          Please type its name, click on its button when it appears, 
          then click the "Continue" button. If this denomination is not yet in the database,
          please add it in order to continue.
        </p>
        <cgroup-filter id="cgroup_filter"
          select_one_mode
          selected_cgroups="{{selected_cgroups}}"></cgroup-filter>
        <cgroup-edit-form id="cgroup_edit_form" hidden="{{hide_cgroup_edit_form}}" cgroup="{{cgroup}}"></cgroup-edit-form>
        <paper-button id="continue_button"
          hidden="{{hide_continue_button}}"
          raised>
          Continue
        </paper-button>
      </div>
      <geocode-stats hidden="{{hide_geocode_stats}}" id="geocode_stats"></geocode-stats>
    </paper-material>
    <google-maps-api id="maps_api" libraries="places"></google-maps-api>
  </template>
</dom-module>
<script>
(function() {
  
  'use strict';

  Polymer({
    is: 'import-a-directory',

    properties: {
      hoodie: {
        type: Object,
        notify: true,
        reflectToAttribute: true
      },
      hide_geocode_stats: {
        type: Boolean,
        value: true,
        notify: true
      },
      hide_cgroup_edit_form: {
        type: Boolean,
        value: true,
        notify: true
      },
      hide_cgroup_filter: {
        type: Boolean,
        value: true,
        notify: true
      },
      cgroup: {
        type: Object,
        value: {},
        notify: true
      },
      geocoder: {
        type: Object,
        value: {},
        notify: true
      },
      hide_continue_button: {
        type: Boolean,
        value: true,
        notify: true
      },
      selected_cgroups: {
        type: Array,
        value: [],
        notify: true
      },
      congs_to_geocode: {
        type: Array,
        value: [],
        notify: true
      }
    },
    observers: [
      '_show_hide_continue_button(selected_cgroups.splices)',
      '_geocode_congs(congs_to_geocode.splices)'
    ],
    ready:function(){
      // TODO: Delete API key above, and ask user to get and enter their own API key for their upload
    },
    attached:function(){
      var thiz = this;

      // Configure geocoder
      this.$.maps_api.addEventListener('api-load', function() {
        thiz.geocoder = new thiz.$.maps_api.api.Geocoder();
      });

      this.async(function(){

        // Get reference to Hoodie
        this.hoodie = document.querySelector('hoodie-accountbar').hoodie;
        
        // Configure listener to congregation:change events
        this.hoodie.store.on('congregation:change', function(eventName, cong){
          // Handle congs with regeocode === true
          if (eventName !== 'remove' && cong.regeocode === true){
            // Add this cong to the queue to enable throttling to work
            thiz.congs_to_geocode.push(cong);
          }
        });
        
        // Trigger regeocoding on page load, after a 5 second delay
        this.async(function(){
          this.hoodie.store.findAll(function(cong){
            if (cong.regeocode === true){
              return true;
            }
          })
          .done(function(congs){
            if (congs.length > 0){
              thiz.congs_to_geocode.push(congs);
            }
          }).fail(thiz.fail_handler);
        }, 5000);

      });
    },
    // Simple default promise fail handler to use throughout the code. It simply logs the error to the console.
    fail_handler:function(error){
      console.log(error);
    },
    /* This function:
     * - gets directory and congregation data from a user-selected import.io file
     * - writes directory and associated cgroup data to the database
     * - geocodes congregations if necessary
     * - writes congregations into the database
     */
    _handle_file_selected:function(event){
      // from old URLView.js:importio_drop_target_drop
      // Get file contents here
      var file = event.target.files[0];
      var reader = new FileReader();
      var thiz = this;
      reader.addEventListener('load', function loadEnd(){
        reader.removeEventListener(event.type, loadEnd);
        var json = reader.result;
        var congs_obj = JSON.parse(json);
        // Determine if this import.io data source is already in a directory in the database.
        // Note that
        //  - a directory object represents one remote church directory website, and
        //  - a cgroup object represents one denomination or group like the OPC, NAPARC, etc.
        //  - a directory represents one cgroup (not many)
        //  So, we need to load a <cgroup-filter> here to allow the user to select the directory's cgroup.
        //  Use the importio_guid to determine this
        var importio_guid = congs_obj.data[0]._source[0];
        // Get this directory if it exists in the db
//         thiz.hoodie.store.removeAll('directory');
//         thiz.hoodie.store.removeAll('congregation');
//         return;
        thiz.hoodie.store.findAll(function(object){
          if (object.type === 'directory' && object.importio_guid === importio_guid){
            return true;
          }
        })
        .done(function(directories){
          // TODO: Refactor from here down into reusable methods, especially because the cong 
          //  translation & geocoding block is big, and needed in both conditional blocks below.
          if (directories.length > 1){
            console.error('There is more than one directory with this importio_guid!');
          }
          if (directories.length === 1){
            // Then display this directory's cgroup
            var directory = directories[0];
            // Find the cgroup which this directory represents, and display it in the <cgroup-filter>
            thiz.hoodie.store.findAll('cgroup')
            .done(function(available_cgroups){
              thiz.$.cgroup_filter.available_cgroups = available_cgroups;
              // Get related cgroup
              thiz.hoodie.store.find('cgroup', directory.cgroup_id)
              .done(function(cgroup){
                // Display related cgroup in <cgroup-filter>
                thiz.$.cgroup_filter.selected_cgroups = [cgroup];
                thiz.hide_cgroup_filter = false;
                // TODO: Start here.  Set up listener (elsewhere in the code) to handle updating the cgroup_directory
                //  docs with their new new cgroups.
              }).fail(thiz.fail_handler);
            }).fail(thiz.fail_handler);
          }else{
            // Else create this directory
            
            // Get domain name
            var a = document.createElement('a');
            a.href = congs_obj.data[0]._pageUrl;
            var domain_name = a.hostname;
            
            // Create directory
            thiz.hoodie.store.add('directory', {
              importio_guid: importio_guid,
              url: domain_name, // url of directory's main page, approximated to domain name
              directory_type:'importio'
            })

            // Associate one cgroup with this directory
            .done(function(directory){
              
              // Display <cgroup-filter> to permit user to select or create the related cgroup
              thiz.hoodie.store.findAll('cgroup')
              .done(function(available_cgroups){
                thiz.$.cgroup_filter.available_cgroups = available_cgroups;
                thiz.hide_cgroup_filter = false;
                // Focus the paper-input to make it easy for a user to start typing
                thiz.$.cgroup_filter.$.filter_input.$.input.focus();
                // Note: There are two ways by which the user can select a cgroup below:
                //  - 1) new or 2) existing
                // 1) If the user adds a new cgroup to the database
                // When the user clicks the button to add a new denomination, save the new cgroup
                thiz.$.cgroup_filter.addEventListener('submit', function handle_cgroup_edit_form_submit(event){
                  thiz.$.cgroup_filter.removeEventListener(event.type, handle_cgroup_edit_form_submit);
                  thiz.$.cgroup_filter.$.cgroup_edit_dialog.close();
                  thiz.hide_cgroup_filter = true;
                  thiz.hoodie.store.add('cgroup', thiz.$.cgroup_filter.$.cgroup_edit_form.cgroup)
                  .done(function(cgroup){
                    // Associate this new cgroup with the directory
                    thiz.hoodie.store.update('directory', directory.id, {cgroup_id: cgroup.id})
                    .done(function(directory){
                      thiz._translate_and_save_congs(congs_obj, directory, cgroup);
                    }).fail(thiz.fail_handler);
                  }).fail(thiz.fail_handler);
                });
                // 2) Else if the user selects an existing cgroup
                thiz.$.continue_button.addEventListener('tap', function handle_cgroup_selection(event){
                  thiz.$.continue_button.removeEventListener(event.type, handle_cgroup_selection);
                  var cgroup = thiz.$.cgroup_filter.selected_cgroups[0];
                  thiz.hide_cgroup_filter = true;
                  // Associate this cgroup with the directory
                  thiz.hoodie.store.update('directory', directory.id, {cgroup_id: cgroup.id})
                  .done(function(directory){
                    thiz._translate_and_save_congs(congs_obj, directory, cgroup);
                  }).fail(thiz.fail_handler);
                });
              });

              // TODO: Does the above work when directory.cgroup_id is null? No.
              //  Or does it create multiple copies of the new cgroup? Yes.
              //  So how can we fix this?

            }).fail(thiz.fail_handler);
          }
        });
        // TODO: Render stats view on geocoding progress
        //thiz.hide_geocode_stats = false;
        
        // TODO: Display a stats view to notify the user of the following stats:
        //  running total: X congs have been geocoded successfully
        //  event: All congs' data have been geocoded successfully
        //  event: X congs failed geocoding (offer link to view the details)
        
      });
      reader.readAsText(file);
    },
    /* Translate from importio cong format to our schema, then save the cong. Note this
     *  currently only handles an importio-formatted congs_obj.
     */
    _translate_and_save_congs: function(congs_obj, directory, cgroup){
      var thiz = this;
      // Note: The attribute which contains the list of cong data objects is called congs_obj.data
      var congs = congs_obj.data;

      congs.forEach(function(cong){
        // Note: Most attributes contain lists.
        // So if an attribute is a list is longer than 1 item, join the items together with <br />
        var new_cong = {};
        // Create a new object which has model.congregation as its prototype
        var cong_template = Object.create(thiz.$.model_object.model.congregation);
        // Import only the fields we want in our model
        Object.keys(cong_template.default_attributes).forEach(function handle_attribute(attribute){
            // Only join if it is of type = array
            new_cong[attribute] = Array.isArray(cong[attribute]) ? cong[attribute].join('<br />') : cong[attribute];
        });
        new_cong.contact_email = (new_cong.hasOwnProperty('contact_email') && typeof new_cong.contact_email !== 'undefined') ?
            new_cong.contact_email.replace('mailto:','') : '';
        // cong._pageUrl contains the cong's unique database id in the URL.  Note that we save this attribute since
        //  it is useful for identifying the cong and data source uniquely if we need to search for it or sync it.
        new_cong.page_url = cong._pageUrl;
        // Handle congs from OPC.org
        if (new_cong.page_url.indexOf('opc.org') !== -1){
            // Note that data[n].name is in ALLCAPS!!  So change to capitalize only the first 
            //  character of each word.
            // TODO: This doesn't work with names including words like 'of'. Maybe that's why they are ALLCAPS.
            new_cong.name = new_cong.name.toLowerCase().replace(/(?:^|\s)\S/g, function(a) { return a.toUpperCase(); });
        }
        // Record the source of this revision of this cong
        new_cong.source_id = directory.id;
        
        // Save to database
        // Find out whether this cong exists in the database
        thiz.hoodie.store.findAll(function(cong_found){
          if (cong_found.type === 'congregation' && cong_found.page_url === new_cong.page_url){
            return true;
          }
        })
        .done(function(congs_found){
          if (congs_found.length > 0){
            // Cong already exists in the database, so update with new attributes
            
            // Compare old address values with new address values.
            //  If the new_cong's values are different, then flag to geocode this cong.
            if (thiz._get_cong_address_to_geocode(new_cong) !== thiz._get_cong_address_to_geocode(congs_found[0])){
              // Set regeocode flag
              new_cong.regeocode = true;
            }
            
            // Update this cong's cgroups
            // First find all related cgroups
            thiz.hoodie.store.findAll(function(doc){
              if (doc.type === 'cgroup_congregation' &&
                  doc.congregation_id === congs_found[0].id && 
                  doc.cgroup_id === cgroup.id){
                return true;
              }
            })
            // Second, add this cgroup if it has not yet been added to the cong's cgroups
            .done(function(cgroup_congregations){
              if (cgroup_congregations.length === 0){
                thiz.hoodie.store.add('cgroup_congregation', {
                  cgroup_id: cgroup.id,
                  congregation_id: congs_found[0].id
                })
                .done(function(){}).fail(thiz.fail_handler);
              }
            }).fail(thiz.fail_handler);
            
            // Update in database
            thiz.update_cong(congs_found[0].id, new_cong);

          }else{
            
            // Cong does not exist in database, so flag to geocode, then create new doc
            new_cong.regeocode = true;
            thiz.hoodie.store.add('congregation', new_cong)
            .done(function(){

              // Create a join doc for this congregation's cgroup
              thiz.hoodie.store.add('cgroup_congregation', {
                cgroup_id: cgroup.id,
                congregation_id: congs_found[0].id
              })
              .done(function(){}).fail(thiz.fail_handler);

            }).fail(thiz.fail_handler);

          }
        }).fail(thiz.fail_handler);
      });
    },

    _get_cong_address_to_geocode:function(cong){
      // Get cong's address to geocode
      // Pick the meeting_address[1|2] which contains a number, else just use meeting_address1
      var address_line = '';
      if (cong.meeting_address1 && cong.meeting_address1.search(/\d/) !== -1){
          address_line = cong.meeting_address1;
      } else if (cong.meeting_address2 && cong.meeting_address2.search(/\d/) !== -1){
          address_line = cong.meeting_address2;
      }else{
          address_line = cong.meeting_address1;
      }
      var address =   address_line + ', ' + 
                      (cong.meeting_city?cong.meeting_city: (cong.mailing_city?cong.mailing_city:'')) + ', ' + 
                      (cong.meeting_state?cong.meeting_state:  (cong.mailing_state?cong.mailing_state:'')) + ' ' + 
                      (cong.meeting_zip?cong.meeting_zip:  (cong.mailing_zip?cong.mailing_zip:''));
      return address;      
    },

    /* Recursive function which geocodes an array of congregations, and throttles back the rate 
     *  if the geocoder tells us we are geocoding too fast.
     *
     * Note that this function is called exclusively as a Polymer observer watching
     *  `this.congs_to_geocode`, which functions as a queue, and should not be called
     *  directly by users' code. That is why its first argument is `changeRecords`, 
     *  which is provided by Polymer.
     */
    _geocode_congs:function(changeRecords, usecs){
      // Don't execute if there are no congs_to_geocode
      if (this.congs_to_geocode.length === 0){
        return;
      }
      var thiz = this;

      // Note the geocoder is limited to 2500 requests per day, then is "rate-limited on a per-second basis."
      //  See https://developers.google.com/maps/documentation/javascript/geocoding
      // TODO: We aren't getting the geocoder attribute correctly.
      if (typeof usecs === 'undefined'){
        usecs = 100;
      }

      // Report progress to user
      this.$.geocode_stats.usecs = usecs;
      this.$.geocode_stats.number_to_geocode = this.congs_to_geocode.length;
      var cong = this.congs_to_geocode[0];
      console.log(usecs + '. Geocoding: ' + this.congs_to_geocode[0].name +', ' + 
        this.congs_to_geocode[0].meeting_city + ', ' + this.congs_to_geocode[0].meeting_state);
      
      var address = this._get_cong_address_to_geocode(cong);
      this.geocoder.geocode( { 'address': address }, function(results, status) {
        // console.log(results, status)
        // TODO: Handle when Google returns multiple possible address matches (results.length > 1, 
        //  or status == 'ZERO_RESULTS'
        if (status === thiz.$.maps_api.api.GeocoderStatus.OK) {
          var loc = results[0].geometry.location;
          cong.geocode = {lat:loc.lat(), lng: loc.lng()};
          cong.regeocode = false;
          // Save cong with updated geocode
          thiz.hoodie.store.update('congregation', cong.id, cong)
          .done(function(){
            
            // Report progress to user
            // Show only if there are more to geocode
            thiz.hide_geocode_stats = (thiz.$.geocode_stats.number_to_geocode === 0);
            thiz.$.geocode_stats.number_geocoded = thiz.$.geocode_stats.number_geocoded + 1;

            // Remove this cong from the thiz.congs_to_geocode
            thiz.congs_to_geocode.splice(0, 1);

            // Reduce the usecs a bit in case we backed off too far
            usecs = usecs - 25;

            // Call this function recursively to geocode the next cong
            thiz._geocode_congs(thiz.congs_to_geocode, usecs);

          }).fail(thiz.fail_handler);
        }else{
          // If we were sending the requests to fast, try this cong again and increase the delay
          if (status === thiz.$.maps_api.api.GeocoderStatus.OVER_QUERY_LIMIT){
            usecs += 100;
            setTimeout(function(){
              thiz._geocode_congs({}, usecs);
            },usecs);
          }else{
            var reason  =   'Code ' + status;
            var msg     = 'address="' + address + '" error=' + reason + '(usecs=' + usecs + 'ms)';
            console.log('Error: ' + msg);
            /* TODO: Handle the following errors
             *  Error: address="340 Calle 7NE, San Juan, PR 00922-1477" error=Code ZERO_RESULTS(usecs=900ms)
             */
            // Remove this cong from the congs array so it will not be geocoded this time.
            thiz.congs_to_geocode.splice(0, 1);
            setTimeout(function(){
              thiz._geocode_congs({}, usecs);
            },usecs);
          }
        }
      });
    },
    update_cong:function(id, cong){
      // Update cong in database
      return this.hoodie.store.update('congregation', id, cong)
      .done(function(cong){
        return cong;
      }).fail(this.fail_handler);
    },
    _show_hide_continue_button:function(){
      if (this.selected_cgroups.length === 0){
        this.hide_continue_button = true;
      }else{
        this.hide_continue_button = false;
      }
    }

  });
})();
</script>
